// 2장 - 타입 시스템

// 2.1 타입의 종류
// '타입'은 자바스크립트에서 다루는 값의 형태에 대한 설명이다.
// 여기서 '형태'란 값에 존재하는 속성과 메서드 그리고 내장되어 있는 typeof 연산자가 설명하는 것을 의미한다.
// 타입스크립트의 가장 기본적인 타입은 자바스크립트의 일곱가지 기본 원시 타입(primitive type)과 동일하다.

// null
// undefined
// boolean
// string
// number
// bigint
// symbol

// 2.1.1 타입 시스템
// 타입 시스템은 프로그래밍 언어가 프로그램에서 가질 수 있는 타입을 이해하는 방법에 대한 규칙 집합이다.
// 기본적으로 타입스크립트의 타입 시스템은 다음과 같이 작동한다.

// - 코드를 읽고 존재하는 모든 타입과 값을 이해한다.
// - 각 값이 초기 선언에서 가질 수 있는 타입을 확인한다.
// - 각 값이 추후 코드에서 어떻게 사용될 수 있는지 모든 방법을 확인한다.
// - 값의 사용법이 타입과 일치하지 않으면 사용자에게 오류를 표시한다.

// 2.1.2 오류 종류
// 타입스크립트를 작성하는 동안 가장 자주 접하게 되는 오류 두 가지는 다음과 같다.
// - 구문오류 : 타입스크립트가 자바스크립트로 변환되는 것을 차단할 경우
// - 타입오류 : 타입 검사기에 따라 일치하지 않는 것이 감지된 경우

// 구문오류
// 구문오류는 타입스크립트가 코드로 이해할 수 없는 잘못된 구문을 감지할 때 발생한다.
// 이는 타입스크립트가 타입스크립트 파일에서 자바스크립트 파일을 올바르게 생성할 수 없도록 차단한다.

// 타입오류
// 타입오류는 타입스크립트의 타입 검사기가 프로그램의 타입에서 오류를 감지했을 때 발생한다.
// 오류가 발생했다고 해서 타입스크립트 구문이 자바스크립트로 변환되는 것을 차단하지는 않는다.
// 하지만 코드가 실행되면 무언가 충돌하거나 예기치 않게 작동할 수 있음을 나타낸다.

// 2.2 할당 가능성
// 타입스크립트는 변수의 초깃값을 읽고 해당 변수가 허용되는 타입을 결정한다.
// 나중에 해당 변수에 새로운 값이 할당되면, 새롭게 할당된 값의 타입이 변수의 타입과 동일한지 확인한다.
// 타입스크립트에서 함수 호출이나 변수에 값을 제공할 수 있는지 여부를 확인하는 것을 '할당 가능성'이라고 한다.
// 즉, 전달된 값이 예상된 타입으로 할당 가능한지 여부를 확인한다.

'Type...is not assignable to type...'

// 위 형태의 오류는 타입스크립트 코드를 작성할 때 만나게 되는 가장 일반적인 오류 중 하나이다.
// 해당 오류 메시지에서 언급된 첫 번째 type은 코드에서 변수에 할당하려고 시도하는 값이다.
// 두 번째 type은 첫 번째 타입, 즉, 값이 할당되는 변수이다.

// 2.3 타입 애너테이션
// 때로는 변수에 타입스크립트가 읽어야 할 초깃값이 없는 경우도 있다. 타입스크립트는 나중에 사용할 변수의 초기 타입을 파악하려고 시도하지 않는다.
// 그리고 기본적으로 변수를 암묵적인 any 타입으로 간주한다. 즉, 변수는 세상의 모든 것이 될 수 있음을 나타낸다.

// 초기 타입을 유추할 수 없는 변수는 진화하는 any라고 부른다.
// 특정 타입을 강제하는 대신 새로운 값이 할당될 때마다 변수 타입에 대한 이해를 발전시킨다.

// 다음 코드를 보면 진화하는 any 변수인 rocker에 처음에는 문자열이 할당되는데,
// 이는 toupperCase() 같은 string 메서드를 갖는 것을 의미하지만, 그 다음에는 number 타입으로 진화되는 것을 확인할 수 있다.

let rocker // 타입: any
rocker = 'Joan Jett' // 타입: string
rocker.toUpperCase() // OK

rocker = 19.58 // 타입: number
rocker.toPrecision(1) // OK

rocker.toUpperCase()

// 타입스크립트는 number 타입으로 진화한 변수가 toUpperCase() 메서드를 호출하는 것을 포착했다.
// 그러나 변수가 string 타입에서 number 타입으로 진화된 것이 처음부터 의도된 것인지에 대한 여부는 더 일찍 알 수 없다.

// 일반적으로 any 타입을 사용해 any 타입으로 진화하는 것을 허용하게 되면 타입스크립트의 타입 검사 목적을 부분적으로 쓸모없게 만든다.
// 타입스크립트는 값이 어떤 타입인지 알고 있을 때 가장 잘 작동한다.
// any 타입을 가진 값에는 타입스크립트의 타입 검사 기능을 잘 적용할 수 없다.
// 검사를 위해 알려진 타입이 없기 때문이다.

// 타입스크립트는 초깃값을 할당하지 않고도 변수의 타입을 선언할 수 있는 구문인 '타입 애너테이션'을 제공한다.
// 타입 애너테이션은 변수 이름 뒤에 배치되며 콜론(:)과 타입 이름을 차례대로 기재한다.
// 다음 타입 애너테이션은 rocker 변수가 string 타입임을 나타낸다.

let rocker2: string
rocker2 = 'Joan Jett'

// 이러한 타입 애너테이션은 타입스크립트에만 존재하며 런타임 코드에 영향을 주지도 않고, 유효한 자바스크립트 구문도 아니다.
// tsc 명령어를 실행해 타입스크립트 소스 코드를 자바스크립트로 컴파일하면 해당 코드가 삭제된다.

// 쉽게 얘기해서 타입 애너테이션은 타입을 지정한다고 이해하면 된다.

// 2.3.1 불필요한 타입 애너테이션
// 타입 애너테이션은 타입스크립트가 자체적으로 수집할 수 없는 정보를 타입스크립트에 제공할 수 있다.
// 타입을 즉시 유추할 수 있는 변수에도 타입 애너테이션을 사용할 수 있다. 하지만 타입스크립트가 아직 알지 못하는 것은 알려주지 못한다.

// 다음 코드에서 string 타입 애너테이션은 중복이다.
// 타입스크립트가 이미 firstName이 string 타입임을 유추할 수 있기 때문이다.

let firstName: string = 'Tina' // 타입 시스템은 변경되지 않음

// 초깃값이 있는 변수에 타입 애너테이션을 추가하면 타입스크립트는 변수에 할당된 값의 타입이 일치하는지 확인한다.
// 많은 개발자들은 아무것도 변하지 않는 변수에는 타입 애너테이션을 추가하지 않기를 선호한다.
// 타입 애너테이션을 수동으로 작성하는 일은 번거롭다. 특히 타입이 변경되거나 복잡한 타입일 때 더욱 그렇다.

// 2.4 타입 형태
// 타입스크립트는 변수에 할당된 값이 원래 타입과 일치하는지 확인하는 것 이상을 수행한다.
// 타입스크립트는 객체에 어떤 멤버 속성이 존재하는지 알고 있다.
// 만약 여러분이 코드에서 변수의 속성에 접근하려고 한다면 타입스크립트는 접근하려는 속성이 해당 변수의 타입에 존재하는지 확인한다.

// string 타입의 rapper 변수를 선언한다고 가정해보자.
// 나중에 rapper 변수를 사용할 때 타입스크립트가 string 타입에서 사용 가능한 작업만을 허용한다.
